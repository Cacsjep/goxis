package acap

/*
#cgo pkg-config: glib-2.0
#include <stdlib.h>
#include <glib.h>
#include <stdbool.h>
*/
import "C"
import (
	"unsafe"
)

// String wraps a C string (*C.char) to manage its lifecycle in Go.
// It provides methods for converting to Go strings and freeing allocated memory.
type cString struct {
	Ptr *C.char
}

// NewString creates a new String instance.
// If `str` is not nil, it creates a C string from the Go string and stores its pointer.
// If `str` is nil, it initializes the String with a nil pointer, suitable for direct C library use.
func newString(str *string) *cString {
	if str == nil {
		return &cString{Ptr: nil}
	}
	cstr := C.CString(*str)
	return &cString{Ptr: cstr}
}

// ToGolang converts the C string to a Go string.
// It returns an empty string if the C string is nil.
func (cs *cString) ToGolang() string {
	if cs.Ptr != nil {
		return C.GoString(cs.Ptr)
	}
	return ""
}

// Free releases the memory allocated for the C string.
// It is safe to call multiple times, but the String should not be used after being freed.
func (cs *cString) Free() {
	if cs.Ptr != nil {
		C.free(unsafe.Pointer(cs.Ptr))
		cs.Ptr = nil
	}
}

// AllocatableCString wraps a pointer to a C string pointer to facilitate
// receiving strings allocated by C functions.
type allocatableCString struct {
	Ptr **C.char
}

// NewAllocatableCString creates an AllocatableCString instance.
// This is useful when a C function expects to allocate a string and return it via a pointer argument.
func newAllocatableCString() *allocatableCString {
	var placeholder *C.char
	return &allocatableCString{Ptr: &placeholder}
}

// ToGolang converts the allocated C string to a Go string and frees the C string.
// It returns an empty string if the C string is nil.
func (ms *allocatableCString) ToGolang() string {
	if *ms.Ptr != nil {
		return C.GoString(*ms.Ptr)
	}
	return ""
}

// Free explicitly frees the memory allocated for the C string.
// Note: ToGolang already frees the memory, so calling Free after ToGolang is not necessary.
func (ms *allocatableCString) Free() {
	if *ms.Ptr != nil {
		C.free(unsafe.Pointer(*ms.Ptr))
		*ms.Ptr = nil
	}
}

// Int wraps a GLib gint type, providing a Go representation for easier handling
// of integers in GLib functions and callbacks.
type cInt struct {
	Ptr C.gint // Ptr holds the GLib gint value.
}

// NewInt initializes and returns a new Int instance. This function is useful
// when you need to create an Int to pass to GLib functions or when starting with
// a new GLib integer value.
func newInt() *cInt {
	return &cInt{}
}

// ToGolang converts the GLib gint to a native Go int. This method facilitates the
// transfer of numeric values from C to Go, allowing Go programs to work with
// the values returned by GLib functions directly.
func (cs *cInt) ToGolang() int {
	return int(cs.Ptr)
}

// Double wraps a GLib gdouble type, offering a Go representation to simplify
// the usage of doubles in GLib functions and callbacks.
type cDouble struct {
	Ptr C.gdouble // Ptr holds the GLib gdouble value.
}

// NewDouble initializes and returns a new Double instance. Similar to NewInt,
// this function is designed for situations where a Double needs to be created
// for interaction with GLib functions or when working with new GLib double values.
func newDouble() *cDouble {
	return &cDouble{}
}

// ToGolang converts the GLib gdouble to a native Go float64. This method is essential
// for translating numeric values from C to Go, enabling Go programs to utilize
// the floating-point values manipulated or generated by GLib functions.
func (cs *cDouble) ToGolang() float64 {
	return float64(cs.Ptr)
}

// Bool wraps a GLib gboolean type, offering a Go representation to facilitate
// the use of boolean values in GLib functions and callbacks.
type cBool struct {
	Ptr C.gboolean // Ptr holds the GLib gboolean value.
}

// NewBool initializes and returns a new Bool instance. This function is useful
// for creating a Bool to interact with GLib functions or when starting with a
// new GLib boolean value.
func newBool() *cBool {
	return &cBool{}
}

// ToGolang converts the GLib gboolean to a native Go bool. This method is crucial
// for translating boolean values from C to Go, enabling Go programs to accurately
// work with the boolean values returned by or used in GLib functions.
func (cs *cBool) ToGolang() bool {
	return ctoGoBoolean(cs.Ptr)
}

// CtoGoBoolean takes a C.gboolean and converts it to a Go bool. Since GLib
// gboolean is typically defined as an integer type where FALSE is 0 and TRUE
// is anything non-zero, this function ensures accurate representation of these
// values in Go's boolean type.
//
// Parameters:
//   - cBool: The C.gboolean value to convert.
//
// Returns:
//   - bool: The converted Go bool value, true if cBool is not FALSE, false otherwise.
func ctoGoBoolean(cBool C.gboolean) bool {
	return cBool != C.FALSE
}

// GoBooleanToC takes a Go bool and converts it to a GLib gboolean. This is
// the inverse operation of CtoGoBoolean, enabling Go boolean values to be
// accurately represented and used in GLib functions that expect gboolean values.
//
// Parameters:
//   - b: The Go bool value to convert.
//
// Returns:
//   - C.gboolean: The converted GLib gboolean value, 1 (TRUE) if b is true, 0 (FALSE) otherwise.
func goBooleanToC(b bool) C.gboolean {
	if b {
		return C.gboolean(1)
	}
	return C.gboolean(0)
}
